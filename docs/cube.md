# Cube

## 我们想要做什么？
这一次我们看看立体的图形是怎么样绘制出来的，正方体很适合。


## 整体流程大致是什么样的？
* 编译着色器。
* 分别初始化各个 buffer，这次不仅仅是顶点位置，还包括顶点颜色与顶点索引。
* 定义矩阵变换，将 JS 中计算出的矩阵传入着色器。
* 使用 `drawElements` API 绘制一帧。


## 有哪些重要的概念？
* MVP 矩阵变换
* Uniform 变量
* 索引形式的绘制

### MVP 矩阵变换
和最简单的三角形示例不同的是，对于较为实际的 WebGL 应用，我们都不会 hard code 最终一个点的坐标位置（即 -1 到 1），而需要通过一系列的数学变换，来完成从顶点坐标到屏幕像素的计算。这里通用的手法是**矩阵变换**，所用到的矩阵主要有这么几个：

* Model 模型矩阵
* View 视图矩阵
* Projection 投影矩阵

它们在概念上的直观的理解是这样的：

* **模型矩阵**决定把物体「放在哪里」，你可以定义出一系列中心在坐标原点的物体，然后把它们平移、旋转、缩放到场景中的各个位置。
* **视图矩阵**决定你的眼睛（即摄像机）的视角。如果想从不同方向观察场景，那么既可以变动场景中每个点的坐标，也可以变换「摄像机的位置」。
* **投影矩阵**将三维空间的点「拍扁」到二维空间，即所谓的透视变换。它定义了一个指定了视角、远近范围与宽高比的「视见体」，在这个区域外的点会被丢弃。

一个 `[x, y, z]` 形式的坐标点，要经过上述三个矩阵的变换后，才能得到它的像素位置。矩阵的变换可以通过矩阵乘法相加，基于 WebGL 列主序矩阵从右向左计算的方式，可以得到形如这样的结构：

``` glsl
gl_Position = projectionMat * viewMat * modelMat * pos;
```

注意在我们实际的代码里，并没有变动摄像机的位置。所以模型矩阵和视图矩阵简化为了一个 `modelViewMat` 矩阵。

> 对于 MVP 矩阵推导的更多相关信息，请参见图形学的基础知识。

### Uniform 变量
要想对所有的顶点都与某个固定的矩阵相乘，或者是想要指定一些全局固定的颜色等变量参数时，可以在着色器中使用 uniform 类型的变量。它不像 attribute 数组那样逐顶点执行，而是直观上很易于理解的一个「着色器级全局变量」。它的使用方式相比于使用 buffer 的素质三连，也非常接近：

1. 在着色器中用 GLSL 定义 `uniform` 变量。
2. 在 JS 代码中调用 gl API，从编译得到的着色器程序中，获得指向着色器变量的指针。
3. 在绘制一帧前，将相应的数据从 JS 中传入着色器。

### 索引形式的绘制
`drawArrays` 是直接将一整段连续的缓冲区中数据逐个绘制的。对于存在大量重复或需要共享顶点的情形，`drawElements` API 支持「先从索引 buffer 中取出指向顶点 buffer 的索引值，再用这个索引值读取顶点 buffer 数组的相应位置」，从而复用一些顶点数据。这是什么概念呢？

例如，假设在 xy 平面上有这么几个组成正方形的顶点：

``` js
[[-1, 1], [1, 1], [-1, -1], [1, -1]]
```

那么如果按照原有的逐三角形方式绘制，由于每次只能绘制一个三角形，故而在默认的绘制模式下，我们需要传入共两个三角形的六个顶点数据：

``` js
[[-1, 1], [1, 1], [-1, -1]] // 第一个三角形
[[-1, -1], [1, -1], [1, 1]] // 第二个三角形
```

但我们可以选择还是使用最简单的四个点，再配合一个**索引数组**：

``` js
// 原始的顶点数据
[[-1, 1], [1, 1], [-1, -1], [1, -1]]

// 先用原数组第 0 1 2 项绘制第一个三角形
// 再用第 2 3 1 项绘制第二个三角形
[[0, 1, 2], [2, 3, 1]]
```

这样就能有效地减少顶点的重复，进而提高绘制效率了。

> WebGL 实际接受扁平的一维数组，这里为了利于阅读而使用了二维数组形式，原理一致。
